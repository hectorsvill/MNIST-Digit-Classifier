I see the codebase as the finished application, and the Prompt as the code that builds it. I want the reader to approach this with the correct mindset and expectations.
- Prompt: [build.prompt](https://github.com/hectorsvill/MNIST-Digit-Classifier/blob/main/build.prompt)

# MNIST Digit Classifier - Local Project with API

This project provides a complete, locally runnable system for classifying handwritten digits using TensorFlow/Keras. It includes scripts to train a Convolutional Neural Network on the MNIST dataset, evaluate its performance, and serve the trained model via a Flask web API with prediction and basic learning endpoints. The code is structured modularly, features a pytest test suite, and is designed for easy setup and execution on your local machine.

Generation Note

The foundational code structure, API implementation, test suite, and documentation for this project were generated by an AI assistant (Gemini 2.5 Pro) based on detailed prompts. While reviewed and potentially modified, this serves as a starting point demonstrating AI-assisted development for ML projects.

## Prerequisites (Python Project)

*   **Python:** Version 3.9 or higher (check TensorFlow compatibility if changing).
*   **Pip:** Python package installer.
*   **Git:** (Optional, for cloning).

## Setup Instructions (Python Project)

1.  **Clone or Download:** Get the project code onto your local machine.
    ```bash
    # If using git
    git clone <your-repository-url>
    cd mnist_local_project
    ```

2.  **Create Virtual Environment:** (Highly Recommended)
    ```bash
    python -m venv venv
    ```

3.  **Activate Virtual Environment:**
    *   Windows: `venv\Scripts\activate`
    *   macOS/Linux: `source venv/bin/activate`

4.  **Install Dependencies:** (Includes `Pillow` now)
    ```bash
    pip install -r requirements.txt
    ```

## Usage (Python Project)

### 1. Training the Model

This script trains the model using the MNIST dataset downloaded by TensorFlow.

*   **Run basic training:**
    ```bash
    python train.py
    ```
    *(Model and plots saved to `models/` directory)*

*   **Run training with custom parameters:**
    ```bash
    python train.py --epochs 5 --lr 0.0005
    ```

### 2. Running the API Server

This script loads the trained model and starts the Flask web server, ready to accept image uploads.

*   **Start the development server:**
    ```bash
    python run_api.py
    ```
    *(Server usually runs on `http://127.0.0.1:5000`)*

*   **Start with Gunicorn (Recommended):**
    ```bash
    # pip install gunicorn # If not already installed
    gunicorn --workers 2 --bind 0.0.0.0:5000 run_api:app
    ```

## API Usage (Accepts Image Uploads)

Interact with the running API using tools like `curl` or the provided Go client script. Endpoints now expect `multipart/form-data`.

#### API Endpoints Documentation

**A. Health Check**

*   **Endpoint:** `/health`
*   **Method:** `GET`
*   **Description:** Checks API status and model loading.
*   **Example `curl`:**
    ```bash
    curl http://127.0.0.1:5000/health
    ```

**B. Predict Digit (from Image)**

*   **Endpoint:** `/predict`
*   **Method:** `POST`
*   **Description:** Predicts the digit from an uploaded image file.
*   **Request Body:** `multipart/form-data` containing:
    *   `image`: The image file (e.g., PNG, JPG).
*   **Success Response (200 OK):**
    ```json
    { "prediction": 7, "confidence": 0.9987 }
    ```
*   **Example `curl`:** (Replace `path/to/your/digit.png`)
    ```bash
    curl -X POST http://127.0.0.1:5000/predict \
         -F "image=@path/to/your/digit.png"
    ```

**C. Online Learning (from Image)**

*   **Endpoint:** `/learn`
*   **Method:** `POST`
*   **Description:** Updates the *in-memory* model using an uploaded image file and its correct label.
*   **Request Body:** `multipart/form-data` containing:
    *   `image`: The image file (e.g., PNG, JPG).
    *   `label`: The correct digit label (0-9) as a form field.
*   **Success Response (200 OK):**
    ```json
    { "message": "Model updated...", "label_provided": 3, ... }
    ```
*   **Example `curl`:** (Replace file path and label)
    ```bash
    curl -X POST http://127.0.0.1:5000/learn \
         -F "image=@path/to/your/digit.png" \
         -F "label=3"
    ```

## Go Client Script (`main.go` - Example Usage)

A separate Go script (`main.go`, provided previously) demonstrates how to interact with this updated API from Go.

*   **Purpose:** Sends image files and form data to the Python Flask API endpoints.
*   **Setup:** Requires Go installed. Save the Go code as `main.go`.
*   **Running:** Execute from the command line. Requires the Python API to be running.
    ```bash
    # Predict using an image file (required flag)
    go run main.go --image=path/to/digit.png

    # Predict and Train using an image file and label
    go run main.go --image=path/to/digit.png --train --label=2

    # Specify a different API URL
    go run main.go --image=digit.png --apiurl=http://other-host:5000
    ```

## Running Tests (Python Project)

The pytest suite verifies the Python code, including the API's ability to handle simulated file uploads.

1.  Activate your virtual environment.
2.  Run from the project root directory:
    ```bash
    pytest
    ```

## About the AI Model (MNIST Digit Classifier)

*   **What it is:** An AI model (specifically, a simple Multi-Layer Perceptron or potentially a Convolutional Neural Network if adapted) trained to recognize handwritten digits (0-9). It learns features like curves, lines, and loops from the MNIST dataset.
*   **Input:**
    *   **To the API:** A standard image file (e.g., PNG, JPG) containing a digit.
    *   **To the Model (Internal):** The API preprocesses the uploaded image. It converts the image to 28x28 pixels grayscale, normalizes the pixel values (scaling them typically between 0.0 for black and 1.0 for white), and flattens this 28x28 grid into a single list (vector) of 784 numbers. This vector is the actual input the neural network processes.
*   **Output:**
    *   The primary output is the predicted digit (an integer from 0 to 9).
    *   It also provides a confidence score (a float, usually between 0 and 1) indicating how certain the model is about its prediction.
*   **Potential Extensions:**
    *   **Use a CNN:** Replace the simple MLP in `src/model.py` with a Convolutional Neural Network for potentially higher accuracy, as CNNs are better suited for image tasks.
    *   **Different Datasets:** Adapt the `data_loader.py` and potentially `model.py` to train on other image datasets (e.g., CIFAR-10 for small color images, Fashion-MNIST).
    *   **Real-time Drawing Input:** Modify the API or create a web frontend to accept drawings from a canvas instead of file uploads.
    *   **Batch Processing:** Add an API endpoint or script to process multiple images at once.
    *   **Deployment:** Package the API using Docker for easier deployment to cloud platforms or servers.
    *   **Robust Online Learning:** The current `/learn` endpoint is basic. A more robust system might involve collecting examples, retraining periodically, versioning models, and implementing strategies to prevent catastrophic forgetting.

## How the Code Works (Python Project - Key Updates)

*   **`src/api/preprocessing.py`:** Contains the `process_uploaded_image` function. This uses the `Pillow` library to open the image file received by the API, convert it to 28x28 grayscale, transform it into a NumPy array, normalize the pixel values, and flatten it into the 784-feature vector the model expects.
*   **`src/api/app.py`:**
    *   The `/predict` and `/learn` endpoints now use `request.files['image']` to access the uploaded image file (a Werkzeug `FileStorage` object).
    *   The `/learn` endpoint uses `request.form['label']` to get the label sent as form data.
    *   These endpoints call `process_uploaded_image` to get the feature vector from the file data before passing it (reshaped) to `model.predict` or `model.train_on_batch`.
    *   Error handling is included for missing files/fields and image processing errors.
*   **`requirements.txt`:** Includes `Pillow` for image handling.
*   **`tests/test_api.py`:** Tests were updated to use `BytesIO` to create in-memory file-like objects and send `multipart/form-data` requests using the Flask test client, simulating actual file uploads. Mocks are used extensively to isolate endpoint logic.
